<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SK BLUEBEE 1 MIN</title>
<style>
  
  
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

body {
  background: radial-gradient(circle at top, #020617 0%, #020024 40%, #000000 100%);
  color: #e5e7eb;
  min-height: 100vh;
  padding: 20px;
}

  
  .api-ok {
  background: rgba(34, 197, 94, 0.15);
  color: #22c55e;
  border: 0.5px solid #22c55e;
    
  margin-top: 5px;  

  padding: 4px 12px;     /* üëà size ‡Æï‡ØÅ‡Æ±‡Øà‡Æö‡Øç‡Æö‡Æ§‡ØÅ */
  border-radius: 8px;   /* üëà small radius */

  font-size: 0.75rem;    /* üëà text small */
  font-weight: 700;
  letter-spacing: 0.3px;

  display: inline-block;
}
  
/* ===== HEADER ===== */
header {
  text-align: center;
  margin-bottom: 30px;
  padding: 20px;
  background: linear-gradient(135deg, #020617, #0f172a);
  border-radius: 18px;
  border: 2px solid #2563eb;
  box-shadow: 0 0 30px rgba(37, 99, 235, 0.45);
}

h1 {
  font-size: 2.3rem;
  background: linear-gradient(90deg, #2563eb, #60a5fa, #ef4444);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  letter-spacing: 1.5px;
}

.subtitle {
  color: #93c5fd;
  opacity: 0.85;
}
  

/* ===== DASHBOARD ===== */
.dashboard {
  display: grid;
  grid-template-columns: 1.1fr 0.9fr;
  gap: 20px;
}

@media (max-width: 768px) {
  .dashboard {
    grid-template-columns: 1fr;
  }
}

/* ===== CARD ===== */
.card {
  background: radial-gradient(circle at top, rgba(15,23,42,.95), rgba(2,6,23,.95));
  border-radius: 16px;
  padding: 18px;
  border: 1px solid rgba(96,165,250,.25);
  box-shadow: 0 0 25px rgba(37,99,235,.25);
}

.card h2 {
  color: #60a5fa;
  margin-bottom: 10px;
  text-shadow: 0 0 8px rgba(96,165,250,.6);
}

/* ===== PREDICTION ===== */
.prediction-box {
  text-align: center;
  padding: 16px;
  background: radial-gradient(circle at top, rgba(37,99,235,.12), rgba(0,0,0,.95));
  border-radius: 12px;
  border: 1px solid rgba(37,99,235,.5);
  box-shadow: 0 0 25px rgba(37,99,235,.45);
}

.prediction-value {
  font-size: 2.7rem;
  font-weight: bold;
  color: #f8fafc;
  text-shadow: 0 0 14px rgba(96,165,250,.8);
}

/* ===== COLORS ===== */
.red { color: #ef4444; }
.green { color: #22c55e; }
.violet { color: #a855f7; }

/* ===== STATUS ===== */
.status {
  padding: 10px;
  border-radius: 8px;
  text-align: center;
  font-weight: 600;
}

.win {
  background: rgba(34,197,94,.15);
  color: #22c55e;
}

.loss {
  background: rgba(239,68,68,.15);
  color: #ef4444;
}

/* ===== BUTTON ===== */
.new-session-btn {
  background: linear-gradient(135deg, #2563eb, #ef4444);
  color: #fff;
  border: none;
  padding: 11px 20px;
  border-radius: 9px;
  font-weight: 700;
  cursor: pointer;
}

/* ===== RULE ANALYSIS ===== */
.rule-analysis {
  margin-top: 6px;
  padding: 10px;
  background: rgba(255,255,255,.03);
  border-radius: 8px;
  border: 1px solid rgba(96,165,250,.25);
  max-height: 200px;
  overflow-y: auto;
}

.rule-analysis-item {
  display: flex;
  justify-content: space-between;
  font-size: .82rem;
}

/* üî• HIDE RULE NAME TEXT (fallback_opposite_above etc.) */
.rule-analysis-item span:first-child {
  display: none;
}

/* ===== MATCHED PAIR ANALYSIS ===== */
.matched-pair-analysis {
  margin-top: 10px;
  padding: 8px;
  background: rgba(255,255,255,.03);
  border-radius: 8px;
  border: 1px solid rgba(96,165,250,.25);
}

/* üî• HIDE: "Trend: big | Best Rule: fallback_opposite_above" */
.matched-pair-analysis > div:nth-child(2) {
  display: none;
}

/* ===== CONSOLE ===== */
.console-entry {
  background: rgba(2,6,23,.85);
  border-left: 3px solid #2563eb;
  padding: 8px;
  border-radius: 10px;
}

.console-status-win { color: #22c55e; }
.console-status-loss { color: #ef4444; }
.console-status-pending { color: #60a5fa; }

  /* ===== PREDICT HISTORY TABLE FIX ===== */

.prediction-history {
  margin-top: 12px;
}

.history-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}

.history-table thead th {
  text-align: left;
  padding: 8px 10px;
  color: #93c5fd;
  font-weight: 600;
  border-bottom: 1px solid rgba(96,165,250,.35);
}

.history-table tbody tr {
  border-bottom: 1px solid rgba(255,255,255,.05);
}

.history-table tbody tr:hover {
  background: rgba(96,165,250,.05);
}

.history-table td {
  padding: 6px 10px;
  vertical-align: middle;
  white-space: nowrap;
}

/* Column alignment */
.history-table td:nth-child(1) {
  font-family: monospace;
  font-size: 0.8rem;
  color: #e5e7eb;
}

.history-table td:nth-child(2) {
  text-transform: capitalize;
  font-weight: 600;
}

.history-table td:nth-child(3) {
  text-align: center;
  font-weight: 700;
}

.history-table td:nth-child(4) {
  font-size: 0.72rem;
  color: #facc15;
}

/* Result colors */
.win-status {
  color: #22c55e;
}

.loss-status {
  color: #ef4444;
}

.pending-status {
  color: #fbbf24;
}

/* Mobile safe */
@media (max-width: 600px) {
  .history-table {
    font-size: 0.75rem;
  }

  .history-table td:nth-child(4) {
    display: none; /* hide rule column on small screens */
  }
}

/* üî• HIDE "RULE USED" COLUMN COMPLETELY */

/* Hide header */
.history-table th:nth-child(4) {
  display: none;
}

/* Hide all rule-used cells */
.history-table td:nth-child(4) {
  display: none;
}
/* üî• HIDE PREDICTION CONSOLE (DETAILED LOG) COMPLETELY */
.console-card {
  display: none !important;
}
/* üî• HIDE RULE FREQUENCY ANALYSIS COMPLETELY */
.rule-analysis {
  display: none !important;
}
/* üî• HIDE RECENT RESULTS LIST */
#recentResults {
  display: none !important;
}
/* üî• HIDE PATTERN TABLE (text details) */
.pattern-info {
  display: none !important;
}
/* üî• HIDE ENTIRE RECENT RESULTS CARD */
.dashboard .card:nth-child(2) {
  display: none !important;
}
/* üî• CENTER CURRENT PREDICTION CARD AFTER HIDING RIGHT CARD */
.dashboard {
  grid-template-columns: 1fr !important;
  justify-items: center;
}

.dashboard > .card {
  width: 100%;
  max-width: 520px; /* adjust if you want wider */
}
/* üî• HIDE PREDICTION STATUS BAR */
#predictionStatus {
  display: none !important;
}
/* üî• HIDE MATCHED PAIR ANALYSIS SECTION */
.matched-pair-analysis {
  display: none !important;

}
/* üî• HIDE COLOR & SIZE SECTION COMPLETELY */
.prediction-details {
  display: none !important;
}
/* üî¥ MAKE PERIOD & JACK NUMBERS RED */
.prediction-box > .prediction-detail > div:first-child,
.prediction-box > div:nth-of-type(2) {
  color: #44ef66;
  font-weight: 600;
}
/* üîµ CENTER NEW SESSION BUTTON */
.new-session-btn {
  display: block;
  margin: 16px auto 0 auto;
}
.win-loss-box {
  display: flex;
  justify-content: space-around;
  margin-top: 12px;
  padding: 10px;
  background: rgba(37,99,235,.12);
  border-radius: 10px;
  font-weight: 700;
}

.win-box {
  color: #22c55e;
}

.loss-box {
  color: #ef4444;
}
  body.light {
    background: #f8fafc;
    color: #020617;
  }

  body.light header,
  body.light .card {
    background: #ffffff;
    color: #020617;
    border-color: #2563eb;
  }

  body.light .prediction-box {
    background: #f1f5f9;
  }

  body.light h1 {
    background: linear-gradient(90deg, #2563eb, #ef4444);
    -webkit-background-clip: text;
    color: transparent;
  

</style>
</head>
<body>
  <audio id="soundWin" src="https://23347-creator.github.io/sk-meowbaby/win.mp3"></audio>
<audio id="soundLoss" src="https://23347-creator.github.io/sk-meowbaby/loss.mp3"></audio>
  <div class="container">
    <header>
      <h1> MEOW BABY</h1>
      <p class="subtitle">
        SOMESH BLUEBEE 07
      </p>
      <div id="apiStatus">API: CHECKING...</div>
</header>
      <div id="apiStatus" style="
  margin-top:10px;
  font-size:0.8rem;
  font-weight:700;
  display:inline-block;
  padding:4px 10px;
  border-radius:20px;
">
  API: CHECKING...
</div>
    </header>

    <div class="dashboard">
      <div class="card">
        <h2>CURRENT PREDICTION</h2>
        <div class="prediction-box">
          <div class="prediction-detail">
            <div>PERIOD</div>
            <div class="detail-value" id="nextPeriodNumber">--</div>
          </div>

          <div class="label center" style="margin-top: 12px;">JACK NUMBERS</div>
          <div class="prediction-value" id="predictedNumber">--</div>

          <div class="prediction-details">
            <div class="prediction-detail">
              <div class="mini-label">COLOR</div>
              <div class="detail-value" id="predictedColor">--</div>
              
            </div>
            <div class="prediction-detail">
              <div>SIZE</div>
              <div class="detail-value" id="predictedSize">--</div>
            </div>
          </div>
        </div>

        <div class="status" id="predictionStatus">Waiting for data...</div>

        <button class="new-session-btn" id="newSessionBtn">REFRESH</button>
        <div class="win-loss-box">
  <div class="win-box">WIN: <span id="winCount">0</span></div>
  <div class="loss-box">LOSS: <span id="lossCount">0</span></div>
</div>
        <div class="rule-analysis">
          <h3>Rule Frequency Analysis</h3>
          <div id="ruleFrequencyDisplay"></div>
        </div>

        <div class="matched-pair-analysis">
          <h3>Matched Pair Analysis</h3>
          <div id="matchedPairDisplay"></div>
        </div>

        <div class="prediction-history">
          <h2 style="font-size: 1.1rem; margin-top: 10px;">PREDICT HISTORY</h2>
          <table class="history-table">
            <thead>
              <tr>
                <th>PERIOD NUMBER</th>
                <th>PREDICTION</th>
                <th>RESULT</th>
                <th>Rule Used</th>
              </tr>
            </thead>
            <tbody id="predictionHistoryBody">
              <!-- History will be populated here -->
            </tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <h2>RECENT RESULTS</h2>
        <div class="recent-results" id="recentResults"></div>
        <div class="pattern-info">
          <h3>PATTERN</h3>
          <div class="pattern-details" id="patternDetails"></div>
          
        </div>
      </div>
    </div>

    

    <div class="card console-card">
      <h2>Prediction Console (Detailed Log)</h2>
      <p class="subtitle" style="font-size: 0.85rem; margin-top: 4px;">
        Every prediction ‚Üí time, period, size, pair, rule, trend, matched pair, violet, win/loss.
      </p>
      <div id="consolePanel" class="console-panel">
        <!-- Console entries will be appended here -->
      </div>
    </div>

    <div class="loading" id="loadingIndicator" style="display: none;">
      <div class="spinner"></div>
      <p>Fetching data and calculating prediction...</p>
    </div>
  </div>
  
  
  <script>

  
    // ========================================================
    // WINGO PREDICTOR - RULE FREQUENCY ANALYSIS
    // ========================================================

    // Color & Size Map
    const colorMap = {
      '0': { color: 'red+violet', size: 'small', baseColor: 'red' },
      '1': { color: 'green', size: 'small', baseColor: 'green' },
      '2': { color: 'red', size: 'small', baseColor: 'red' },
      '3': { color: 'green', size: 'small', baseColor: 'green' },
      '4': { color: 'red', size: 'small', baseColor: 'red' },
      '5': { color: 'green+violet', size: 'big', baseColor: 'green' },
      '6': { color: 'red', size: 'big', baseColor: 'red' },
      '7': { color: 'green', size: 'big', baseColor: 'green' },
      '8': { color: 'red', size: 'big', baseColor: 'red' },
      '9': { color: 'green', size: 'big', baseColor: 'green' }
    };

    // Helpers
    function getSize(n) { return colorMap[n].size; }
    function getBaseColor(n) { return colorMap[n].baseColor; }
    function hasViolet(n) { return colorMap[n].color.includes("violet"); }
    function oppositeSize(s) { return s === "big" ? "small" : "big"; }

    // GAME DATA
    let gameData = [];

    // PREDICTION HISTORY
    let predictionHistory = JSON.parse(localStorage.getItem('predictionHistory')) || [];

    // CONSOLE LOGS
    let consoleLogs = JSON.parse(localStorage.getItem('consoleLogs')) || [];

    // All available rules
    const ALL_RULES = [
      "color_match_follow_trend",
      "size_match_break_trend",
      "both_match_break_trend",
      "neither_match_opposite_above",
      "opposite_size_opposite_above",
      "opposite_color_opposite_above",
      "neither_match_1violet_same_above",
      "opposite_size_1violet_same_above",
      "opposite_color_1violet_opposite_above",
      "two_violets_same_predicted",
      "fallback_opposite_above"
    ];

    // Get trend from first four results
    function analyzeFirstFourTrend() {
      if (gameData.length < 4) return null;

      const shortSlice = gameData.slice(0, 4);
      const shortSizes = shortSlice.map(item => getSize(item.number));
      const shortBig = shortSizes.filter(s => s === 'big').length;
      const shortSmall = shortSizes.filter(s => s === 'small').length;

      let shortTrend = null;
      if (shortBig >= 3 && shortBig > shortSmall) {
        shortTrend = 'big';
      } else if (shortSmall >= 3 && shortSmall > shortBig) {
        shortTrend = 'small';
      } else {
        shortTrend = shortSizes[0];
      }

      return shortTrend;
    }

    // Find all matched pairs for current first two numbers
    function findMatchedPairs() {
      if (gameData.length < 4) return [];
      
      const A = gameData[0]; // Latest first number
      const B = gameData[1]; // Latest second number
      
      const matchedPairs = [];
      
      // Start from index 2 (since we need at least 2 positions before for "above")
      for (let i = 2; i < gameData.length - 3; i++) {
        if (gameData[i].number === A.number && gameData[i + 1].number === B.number) {
          const matchedPair = {
            index: i,
            position: i,
            pairAbove: gameData[i - 1], // Number above the matched pair
            pairBelow1: gameData[i + 2], // First number below the matched pair
            pairBelow2: gameData[i + 3], // Second number below the matched pair
            periodAbove: gameData[i - 1].issueNumber,
            periodBelow1: gameData[i + 2].issueNumber,
            periodBelow2: gameData[i + 3].issueNumber,
            thirdNumber: gameData[2].number, // Current third number
            fourthNumber: gameData[3].number  // Current fourth number
          };
          matchedPairs.push(matchedPair);
        }
      }
      
      return matchedPairs;
    }

    // Check which rules are satisfied for a matched pair
    function checkRulesForMatchedPair(matchedPair, trend) {
      const above = matchedPair.pairAbove;
      const below1 = matchedPair.pairBelow1;
      const below2 = matchedPair.pairBelow2;
      const third = { number: matchedPair.thirdNumber };
      const fourth = { number: matchedPair.fourthNumber };
      
      const colorMatch =
        getBaseColor(third.number) === getBaseColor(below1.number) &&
        getBaseColor(fourth.number) === getBaseColor(below2.number);

      const sizeMatch =
        getSize(third.number) === getSize(below1.number) &&
        getSize(fourth.number) === getSize(below2.number);

      const oppositeColorMatch =
        getBaseColor(third.number) !== getBaseColor(below1.number) &&
        getBaseColor(fourth.number) !== getBaseColor(below2.number);

      const oppositeSizeMatch =
        getSize(third.number) !== getSize(below1.number) &&
        getSize(fourth.number) !== getSize(below2.number);

      const violetCount = [below1.number, below2.number].filter(num => hasViolet(num)).length;
      const hasOneViolet = violetCount === 1;
      const hasTwoViolets = violetCount === 2;
      
      const satisfiedRules = [];
      
      // Check each rule
      if (colorMatch && !sizeMatch) {
        satisfiedRules.push("color_match_follow_trend");
      }
      
      if (!colorMatch && sizeMatch) {
        if (hasOneViolet) {
          satisfiedRules.push("size_match_break_trend_violet_flip");
        } else {
          satisfiedRules.push("size_match_break_trend");
        }
      }
      
      if (colorMatch && sizeMatch) {
        satisfiedRules.push("both_match_break_trend");
      }
      
      if (!colorMatch && !sizeMatch && !oppositeColorMatch && !oppositeSizeMatch && !hasOneViolet) {
        satisfiedRules.push("neither_match_opposite_above");
      }
      
      if (oppositeSizeMatch && !hasOneViolet) {
        satisfiedRules.push("opposite_size_opposite_above");
      }
      
      if (oppositeColorMatch && !hasOneViolet) {
        satisfiedRules.push("opposite_color_opposite_above");
      }
      
      if (!colorMatch && !sizeMatch && hasOneViolet) {
        satisfiedRules.push("neither_match_1violet_same_above");
      }
      
      if (oppositeSizeMatch && hasOneViolet) {
        satisfiedRules.push("opposite_size_1violet_same_above");
      }
      
      if (oppositeColorMatch && hasOneViolet) {
        satisfiedRules.push("opposite_color_1violet_opposite_above");
      }
      
      if (hasTwoViolets) {
        satisfiedRules.push("two_violets_same_predicted");
      }
      
      // Fallback rule always applies
      satisfiedRules.push("fallback_opposite_above");
      
      return {
        satisfiedRules,
        aboveSize: getSize(above.number),
        below1Size: getSize(below1.number),
        below2Size: getSize(below2.number),
        colorMatch,
        sizeMatch,
        oppositeColorMatch,
        oppositeSizeMatch,
        violetCount,
        aboveNumber: above.number,
        below1Number: below1.number,
        below2Number: below2.number
      };
    }

    // Analyze all matched pairs and find most frequent rule
    function analyzeMatchedPairs() {
      if (gameData.length < 4) return null;
      
      const matchedPairs = findMatchedPairs();
      if (matchedPairs.length === 0) return null;
      
      const trend = analyzeFirstFourTrend();
      const ruleFrequency = {};
      const matchedPairDetails = [];
      
      // Initialize rule frequency counter
      ALL_RULES.forEach(rule => {
        ruleFrequency[rule] = 0;
      });
      
      // Check rules for each matched pair
      matchedPairs.forEach(pair => {
        const analysis = checkRulesForMatchedPair(pair, trend);
        
        // Count satisfied rules
        analysis.satisfiedRules.forEach(rule => {
          if (ruleFrequency[rule] !== undefined) {
            ruleFrequency[rule]++;
          }
        });
        
        matchedPairDetails.push({
          position: pair.position,
          aboveNumber: analysis.aboveNumber,
          below1Number: analysis.below1Number,
          below2Number: analysis.below2Number,
          aboveSize: analysis.aboveSize,
          satisfiedRules: analysis.satisfiedRules,
          colorMatch: analysis.colorMatch,
          sizeMatch: analysis.sizeMatch,
          violetCount: analysis.violetCount
        });
      });
      
      // Find most frequent rule
      let mostFrequentRule = "fallback_opposite_above";
      let highestFrequency = 0;
      
      Object.keys(ruleFrequency).forEach(rule => {
        if (ruleFrequency[rule] > highestFrequency) {
          highestFrequency = ruleFrequency[rule];
          mostFrequentRule = rule;
        }
      });
      
      return {
        matchedPairsCount: matchedPairs.length,
        ruleFrequency,
        mostFrequentRule,
        highestFrequency,
        matchedPairDetails,
        currentPair: `${gameData[0].number}${gameData[1].number}`,
        trend
      };
    }

    // Apply the most frequent rule to make a prediction
    function applyRulePrediction(analysis) {
      if (!analysis) return null;
      
      const trend = analysis.trend;
      const mostFrequentRule = analysis.mostFrequentRule;
      
      // Find the latest matched pair
      const matchedPairs = findMatchedPairs();
      if (matchedPairs.length === 0) return null;
      
      const latestMatchedPair = matchedPairs[0]; // Most recent one
      const above = latestMatchedPair.pairAbove;
      const below1 = latestMatchedPair.pairBelow1;
      const below2 = latestMatchedPair.pairBelow2;
      const third = { number: gameData[2].number };
      const fourth = { number: gameData[3].number };
      
      const colorMatch =
        getBaseColor(third.number) === getBaseColor(below1.number) &&
        getBaseColor(fourth.number) === getBaseColor(below2.number);

      const sizeMatch =
        getSize(third.number) === getSize(below1.number) &&
        getSize(fourth.number) === getSize(below2.number);

      const oppositeColorMatch =
        getBaseColor(third.number) !== getBaseColor(below1.number) &&
        getBaseColor(fourth.number) !== getBaseColor(below2.number);

      const oppositeSizeMatch =
        getSize(third.number) !== getSize(below1.number) &&
        getSize(fourth.number) !== getSize(below2.number);

      const violetCount = [below1.number, below2.number].filter(num => hasViolet(num)).length;
      const hasOneViolet = violetCount === 1;
      const hasTwoViolets = violetCount === 2;
      
      let predictedSize = null;
      
      // Apply the most frequent rule
      switch(mostFrequentRule) {
        case "color_match_follow_trend":
          if (colorMatch && !sizeMatch) {
            predictedSize = trend;
          }
          break;
          
        case "size_match_break_trend":
          if (!colorMatch && sizeMatch) {
            predictedSize = oppositeSize(trend);
            if (hasOneViolet) {
              predictedSize = oppositeSize(predictedSize);
            }
          }
          break;
          
        case "both_match_break_trend":
          if (colorMatch && sizeMatch) {
            predictedSize = oppositeSize(trend);
          }
          break;
          
        case "neither_match_opposite_above":
          if (!colorMatch && !sizeMatch && !oppositeColorMatch && !oppositeSizeMatch) {
            predictedSize = oppositeSize(getSize(above.number));
          }
          break;
          
        case "opposite_size_opposite_above":
          if (oppositeSizeMatch) {
            predictedSize = oppositeSize(getSize(above.number));
          }
          break;
          
        case "opposite_color_opposite_above":
          if (oppositeColorMatch) {
            predictedSize = oppositeSize(getSize(above.number));
          }
          break;
          
        case "neither_match_1violet_same_above":
          if (!colorMatch && !sizeMatch && hasOneViolet) {
            predictedSize = getSize(above.number);
          }
          break;
          
        case "opposite_size_1violet_same_above":
          if (oppositeSizeMatch && hasOneViolet) {
            predictedSize = getSize(above.number);
          }
          break;
          
        case "opposite_color_1violet_opposite_above":
          if (oppositeColorMatch && hasOneViolet) {
            predictedSize = oppositeSize(getSize(above.number));
          }
          break;
          
        case "two_violets_same_predicted":
          if (hasTwoViolets) {
            predictedSize = getSize(above.number);
          }
          break;
          
        case "fallback_opposite_above":
          predictedSize = oppositeSize(getSize(above.number));
          break;
      }
      
      // If rule doesn't apply, use fallback
      if (!predictedSize) {
        predictedSize = oppositeSize(getSize(above.number));
      }
      
      return {
        size: predictedSize,
        rule: mostFrequentRule,
        ruleFrequency: analysis.highestFrequency,
        matchedPairsCount: analysis.matchedPairsCount
      };
    }

    // Helper: number pairs per size
    function getNumberPairForSize(size, index) {
      if (size === "small") {
        const smallPairs = [
          ["0", "2"], ["1", "3"], ["2", "4"], ["0", "3"], ["1", "4"]
        ];
        const pairIndex = index % smallPairs.length;
        return smallPairs[pairIndex];
      } else {
        const bigPairs = [
          ["5", "7"], ["6", "8"], ["7", "9"], ["5", "8"], ["6", "9"]
        ];
        const pairIndex = index % bigPairs.length;
        return bigPairs[pairIndex];
      }
    }

    // FINAL PREDICTION
    function predictNext() {
      if (gameData.length < 4) {
        return { status: "NO_DATA" };
      }

      // Analyze matched pairs
      const analysis = analyzeMatchedPairs();
      
      if (!analysis || analysis.matchedPairsCount === 0) {
        // No matched pairs found, use trend-based prediction
        const trend = analyzeFirstFourTrend();
        const fallbackSize = trend === 'big' ? 'small' : 'big';
        const numbers = getNumberPairForSize(fallbackSize, 0);
        
        return {
          status: "OK",
          size: fallbackSize,
          numbers: numbers,
          rule: `fallback_trend_based`,
          matchCount: 0,
          matchedPairsCount: 0
        };
      }
      
      // Apply the most frequent rule
      const prediction = applyRulePrediction(analysis);
      
      if (!prediction) {
        const trend = analyzeFirstFourTrend();
        const fallbackSize = trend === 'big' ? 'small' : 'big';
        const numbers = getNumberPairForSize(fallbackSize, 0);
        
        return {
          status: "OK",
          size: fallbackSize,
          numbers: numbers,
          rule: `fallback_no_prediction`,
          matchCount: 0,
          matchedPairsCount: analysis.matchedPairsCount
        };
      }
      
      const numbers = getNumberPairForSize(prediction.size, 0);
      
      return {
        status: "OK",
        size: prediction.size,
        numbers: numbers,
        rule: `${prediction.rule}_freq${prediction.ruleFrequency}`,
        matchCount: prediction.matchedPairsCount,
        matchedPairsCount: prediction.matchedPairsCount,
        analysis: analysis
      };
    }

    // Render rule frequency analysis
    function renderRuleFrequency(analysis) {
      const ruleFrequencyDisplay = document.getElementById('ruleFrequencyDisplay');
      const matchedPairDisplay = document.getElementById('matchedPairDisplay');
      
      if (!analysis) {
        ruleFrequencyDisplay.innerHTML = '<div style="color: #ff6b6b; text-align: center;">No matched pairs found</div>';
        matchedPairDisplay.innerHTML = '<div style="color: #ff6b6b; text-align: center;">No matched pairs found</div>';
        return;
      }
      
      // Sort rules by frequency
      const sortedRules = Object.keys(analysis.ruleFrequency)
        .filter(rule => analysis.ruleFrequency[rule] > 0)
        .sort((a, b) => analysis.ruleFrequency[b] - analysis.ruleFrequency[a]);
      
      let ruleHTML = '';
      sortedRules.forEach(rule => {
        const isBest = rule === analysis.mostFrequentRule;
        const ruleClass = isBest ? 'best-rule' : '';
        
        ruleHTML += `
          <div class="rule-analysis-item ${ruleClass}">
            <span>${rule}:</span>
            <span class="rule-count">${analysis.ruleFrequency[rule]} times</span>
          </div>
        `;
      });
      
      if (sortedRules.length === 0) {
        ruleHTML = '<div style="color: #ffd166; text-align: center;">No rules satisfied</div>';
      }
      
      // Show matched pair details
      let matchedHTML = `
        <div class="analysis-header">
          <span>Current Pair: ${analysis.currentPair}</span>
          <span>Matched: ${analysis.matchedPairsCount} times</span>
        </div>
        <div style="font-size: 0.75rem; color: #ffd166; margin-bottom: 8px;">
          Trend: ${analysis.trend} | Best Rule: ${analysis.mostFrequentRule}
        </div>
      `;
      
      // Show first few matched pair details
      analysis.matchedPairDetails.slice(0, 5).forEach(detail => {
        matchedHTML += `
          <div class="matched-pair-item">
            <span>Pos ${detail.position}: Above=${detail.aboveNumber}(${detail.aboveSize})</span>
            <span>Below=${detail.below1Number},${detail.below2Number}</span>
          </div>
        `;
      });
      
      if (analysis.matchedPairDetails.length > 5) {
        matchedHTML += `<div style="color: #ffd166; text-align: center; margin-top: 5px;">+${analysis.matchedPairDetails.length - 5} more</div>`;
      }
      
      ruleFrequencyDisplay.innerHTML = ruleHTML;
      matchedPairDisplay.innerHTML = matchedHTML;
    }

    // UI Elements
    const predictedNumber = document.getElementById('predictedNumber');
    const predictedColor = document.getElementById('predictedColor');
    const predictedSize = document.getElementById('predictedSize');
    const nextPeriodNumber = document.getElementById('nextPeriodNumber');
    const predictionStatus = document.getElementById('predictionStatus');
    const recentResults = document.getElementById('recentResults');
    const patternDetails = document.getElementById('patternDetails');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const predictionHistoryBody = document.getElementById('predictionHistoryBody');
    const newSessionBtn = document.getElementById('newSessionBtn');
    const consolePanel = document.getElementById('consolePanel');
    const winCountEl = document.getElementById('winCount');
    const lossCountEl = document.getElementById('lossCount');
  
    // Utility
    function getNextPeriod(currentPeriod) {
      let periodStr = String(currentPeriod);
      let prefix = periodStr.slice(0, -5);
      let lastPart = periodStr.slice(-5);
      let nextLastPart = String(Number(lastPart) + 1).padStart(5, '0');
      return prefix + nextLastPart;
    }

    // New session
    function startNewSession() {
      predictionHistory = [];
      localStorage.setItem('predictionHistory', JSON.stringify(predictionHistory));

      consoleLogs = [];
      localStorage.setItem('consoleLogs', JSON.stringify(consoleLogs));

      renderPredictionHistory();
      renderConsoleLogs();

      predictionStatus.textContent = "New session started. All history cleared.";
      predictionStatus.className = "status win";

      predictedNumber.textContent = "--";
      predictedSize.textContent = "--";
      predictedColor.textContent = "--";
      nextPeriodNumber.textContent = "--";
    }

    // Console log
    function addConsoleLogFromPrediction(period, prediction, analysis) {
      if (!prediction || prediction.status !== "OK") return;
      
      const trend = analyzeFirstFourTrend();
      const matchedPairs = findMatchedPairs();
      const latestMatchedPair = matchedPairs.length > 0 ? matchedPairs[0] : null;
      const violetInMatchedPair = latestMatchedPair
        ? [latestMatchedPair.pairBelow1.number, latestMatchedPair.pairBelow2.number].filter(num => num === '0' || num === '5').length
        : 0;

      const log = {
        period: period,
        createdAt: new Date().toISOString(),
        size: prediction.size,
        numbers: prediction.numbers,
        rule: prediction.rule,
        matchCount: prediction.matchedPairsCount || 0,
        trend: trend,
        matchedPair: latestMatchedPair,
        violetInMatchedPair: violetInMatchedPair,
        result: "pending ‚è≥",
        analysis: analysis ? {
          currentPair: analysis.currentPair,
          matchedPairsCount: analysis.matchedPairsCount,
          mostFrequentRule: analysis.mostFrequentRule,
          highestFrequency: analysis.highestFrequency
        } : null
      };

      consoleLogs.unshift(log);
      if (consoleLogs.length > 100) {
        consoleLogs.pop();
      }
      localStorage.setItem('consoleLogs', JSON.stringify(consoleLogs));
      renderConsoleLogs();
    }

    function renderConsoleLogs() {
      consolePanel.innerHTML = '';

      if (!consoleLogs || consoleLogs.length === 0) {
        consolePanel.innerHTML = '<div style="font-size:0.85rem;opacity:0.7;">No console logs yet. Wait for predictions.</div>';
        return;
      }

      consoleLogs.forEach(log => {
        const entry = document.createElement('div');
        entry.className = 'console-entry';

        const header = document.createElement('div');
        header.className = 'console-header-line';

        let statusClass = 'console-status-pending';
        if (log.result === 'Win ‚úÖ') statusClass = 'console-status-win';
        else if (log.result === 'Loss ‚ùå') statusClass = 'console-status-loss';

        header.innerHTML = `
          <span>[${new Date(log.createdAt).toLocaleTimeString()}] Period: ${log.period}</span>
          <span class="${statusClass}">${log.result || 'pending ‚è≥'}</span>
        `;

        const body = document.createElement('div');
        body.className = 'console-body';

        const above = log.matchedPair ? log.matchedPair.pairAbove.number : 'N/A';
        const below1 = log.matchedPair ? log.matchedPair.pairBelow1.number : 'N/A';
        const below2 = log.matchedPair ? log.matchedPair.pairBelow2.number : 'N/A';

        let analysisText = '';
        if (log.analysis) {
          analysisText = `
Current Pair: ${log.analysis.currentPair}
Matched Pairs: ${log.analysis.matchedPairsCount}
Most Frequent Rule: ${log.analysis.mostFrequentRule}
Rule Frequency: ${log.analysis.highestFrequency}
`;
        }

        body.textContent =
`Prediction Size: ${log.size}
Prediction Numbers: ${log.numbers ? log.numbers.join(' or ') : 'N/A'}
Rule Used: ${log.rule}
First-Four Trend: ${log.trend}
Match Count: ${log.matchCount}
${analysisText}
Matched Pair Above: ${above}
Matched Pair Below 1: ${below1}
Matched Pair Below 2: ${below2}
Violet in Matched Pair: ${log.violetInMatchedPair}`;

        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy';
        copyBtn.addEventListener('click', () => {
          const text =
`Time: ${new Date(log.createdAt).toLocaleString()}
Period: ${log.period}
Result: ${log.result}

Prediction Size: ${log.size}
Prediction Numbers: ${log.numbers ? log.numbers.join(' or ') : 'N/A'}
Rule Used: ${log.rule}
First-Four Trend: ${log.trend}
Match Count: ${log.matchCount}

${analysisText ? analysisText : ''}
Matched Pair Above: ${above}
Matched Pair Below 1: ${below1}
Matched Pair Below 2: ${below2}
Violet in Matched Pair: ${log.violetInMatchedPair}
`;
          navigator.clipboard.writeText(text);
        });

        entry.appendChild(header);
        entry.appendChild(body);
        entry.appendChild(copyBtn);

        consolePanel.appendChild(entry);
      });
    }

    // Prediction history
    function 
   updatePredictionHistory() {
  if (gameData.length > 0) {
    const currentPeriod = gameData[0].issueNumber;
    const currentNumber = gameData[0].number;
    const currentSize = getSize(currentNumber);

    predictionHistory.forEach(prediction => {
      if (
        prediction.period === currentPeriod &&
        prediction.result === "pending ‚è≥"
      ) {
        const isWin = prediction.prediction === currentSize;
        prediction.result = isWin ? "Win ‚úÖ" : "Loss ‚ùå";

// üîä PLAY SOUND HERE (CORRECT PLACE)
const winSound = document.getElementById("soundWin");
const lossSound = document.getElementById("soundLoss");

if (isWin) {
  winSound.currentTime = 0;
  winSound.play().catch(()=>{});
} else {
  lossSound.currentTime = 0;
  lossSound.play().catch(()=>{});
}
        const idx = consoleLogs.findIndex(
          log => log.period === prediction.period
        );
        if (idx !== -1) {
          consoleLogs[idx].result = prediction.result;
        }
      }
    });

    // Save updates
    localStorage.setItem(
      'predictionHistory',
      JSON.stringify(predictionHistory)
    );
    localStorage.setItem(
      'consoleLogs',
      JSON.stringify(consoleLogs)
    );
  }

  // ===== WIN / LOSS COUNT (ATTACHED HERE) =====
  const wins = predictionHistory.filter(
    p => p.result === "Win ‚úÖ"
  ).length;

  const losses = predictionHistory.filter(
    p => p.result === "Loss ‚ùå"
  ).length;

  winCountEl.textContent = wins;
  lossCountEl.textContent = losses;

  // Existing renders
  renderPredictionHistory();
  renderConsoleLogs();
}
   

    function addPredictionToHistory(period, predictionObj) {
      const existingIndex = predictionHistory.findIndex(p => p.period === period);

      if (existingIndex === -1 && predictionObj.status === "OK") {
        predictionHistory.unshift({
          period: period,
          prediction: predictionObj.size,
          result: "pending ‚è≥",
          ruleUsed: predictionObj.rule
        });

        if (predictionHistory.length > 20) {
          predictionHistory.pop();
        }

        localStorage.setItem('predictionHistory', JSON.stringify(predictionHistory));
      }

      renderPredictionHistory();
    }

    function renderPredictionHistory() {
      predictionHistoryBody.innerHTML = '';

      if (predictionHistory.length === 0) {
        predictionHistoryBody.innerHTML =
          '<tr><td colspan="4" style="text-align: center;">No prediction history yet</td></tr>';
        return;
      }

      predictionHistory.forEach(prediction => {
        const row = document.createElement('tr');

        const periodCell = document.createElement('td');
        periodCell.textContent = prediction.period;

        const predictionCell = document.createElement('td');
        predictionCell.textContent = prediction.prediction;

        const resultCell = document.createElement('td');
        resultCell.textContent = prediction.result;

        const ruleCell = document.createElement('td');
        ruleCell.textContent = prediction.ruleUsed || 'N/A';
        ruleCell.style.fontSize = '0.8rem';

        if (prediction.result === "Win ‚úÖ") {
          resultCell.className = 'win-status';
        } else if (prediction.result === "Loss ‚ùå") {
          resultCell.className = 'loss-status';
        } else {
          resultCell.className = 'pending-status';
        }

        row.appendChild(periodCell);
        row.appendChild(predictionCell);
        row.appendChild(resultCell);
        row.appendChild(ruleCell);

        predictionHistoryBody.appendChild(row);
      });
    }

    // Prediction UI
    function updatePredictionUI(prediction) {
      if (prediction.status === "NO_DATA") {
        predictedNumber.textContent = "--";
        predictedSize.textContent = "--";
        predictedColor.textContent = "--";
        predictionStatus.textContent = "Waiting for data...";
        predictionStatus.className = "status";
      } else if (prediction.status === "OK") 
      {
        const telegramMessage = `
<b>ü§ñ SK BLUEBEE PREDICTION</b>

üïí Period: ${nextPeriodNumber.textContent}
üéØ Size: <b>${prediction.size.toUpperCase()}</b>
üî¢ Numbers: ${prediction.numbers.join(" or ")}

‚ö° Good Luck!
`;


      }
      {
        predictedNumber.textContent = prediction.numbers.join(" or ");
        predictedSize.textContent = prediction.size;
        predictedColor.textContent = getBaseColor(prediction.numbers[0]);

        predictionStatus.textContent =
          `Prediction ready (${prediction.rule}) | Matched Pairs: ${prediction.matchedPairsCount}`;
        predictionStatus.className = "status win";

        const nextPeriod = getNextPeriod(gameData[0].issueNumber);
        addPredictionToHistory(nextPeriod, prediction);
        
        // Render rule frequency analysis
        renderRuleFrequency(prediction.analysis);
      }

      if (gameData.length > 0) {
        nextPeriodNumber.textContent = getNextPeriod(gameData[0].issueNumber);
      } else {
        nextPeriodNumber.textContent = "--";
      }
    }

    // Recent results
    function updateRecentResults() {
      recentResults.innerHTML = '';
      gameData.slice(0, 10).forEach(item => {
        const colorInfo = colorMap[item.number];
        if (colorInfo) {
          const div = document.createElement('div');
          div.className = 'result';

          const colorClass = colorInfo.color.includes('red')
            ? 'red'
            : colorInfo.color.includes('green')
              ? 'green'
              : colorInfo.color.includes('violet')
                ? 'violet'
                : '';

          div.innerHTML = `
            <div class="result-number ${colorClass}">${item.number}</div>
            <div class="result-size">${colorInfo.size}</div>
          `;
          recentResults.appendChild(div);
          
        }
      });
    }

    // Pattern details UI
    function updatePatternDetails(prediction) {
      const A = gameData[0];
      const B = gameData[1];
      const third = gameData[2];
      const fourth = gameData[3];
      const trend = analyzeFirstFourTrend();
      
      const matchedPairs = findMatchedPairs();
      const matchedCount = matchedPairs.length;
      const latestMatchedPair = matchedCount > 0 ? matchedPairs[0] : null;
      
      let patternHTML = `
        <div class="pattern-item"><span>Current Pair:</span><span>${A.number}, ${B.number}</span></div>
        <div class="pattern-item"><span>3rd/4th Results:</span><span>${third.number}(${getSize(third.number)}), ${fourth.number}(${getSize(fourth.number)})</span></div>
        <div class="pattern-item"><span>First-Four Trend:</span><span>${trend || 'N/A'}</span></div>
        <div class="pattern-item"><span>Matched Pairs Found:</span><span>${matchedCount}</span></div>
      `;
      
      if (latestMatchedPair) {
        patternHTML += `
          <div class="pattern-item"><span>Latest Above:</span><span>${latestMatchedPair.pairAbove.number}(${getSize(latestMatchedPair.pairAbove.number)})</span></div>
          <div class="pattern-item"><span>Latest Below:</span><span>${latestMatchedPair.pairBelow1.number},${latestMatchedPair.pairBelow2.number}</span></div>
        `;
      }
      
      if (prediction.status === "OK") {
        patternHTML += `
          <div class="pattern-item"><span>Selected Rule:</span><span>${prediction.rule.split('_')[0]}</span></div>
          <div class="pattern-item"><span>Prediction Size:</span><span>${prediction.size}</span></div>
        `;
      }
      
      patternDetails.innerHTML = patternHTML;
    }
async function fetchData() {
  const apiStatusEl = document.getElementById("apiStatus");
  try {
    loadingIndicator.style.display = 'block';

    const response = await fetch('https://Harshpredictor.site/api/api.php', {
      cache: "no-store"
    });

    const data = await response.json();

    if (data && data.data && data.data.list) {
      gameData = data.data.list;
      gameData.sort((a, b) => Number(b.issueNumber) - Number(a.issueNumber));

      apiStatusEl.textContent = "API: CONNECTED";
      apiStatusEl.className = "api-ok";

      loadingIndicator.style.display = 'none';
      return true;
    } else {
      throw new Error("Invalid data");
    }
  } catch (error) {
    console.error("API Error:", error);

    apiStatusEl.textContent = "API: DOWN";
    apiStatusEl.className = "api-fail";

    loadingIndicator.style.display = 'none';
    predictionStatus.textContent = "API error. Waiting...";
    predictionStatus.className = "status loss";
    return false;
  }
}

    async function fetchDataAndPredict() {
      const success = await fetchData();
      if (success) {
        updatePredictionHistory();
        
        // Make prediction
        const prediction = predictNext();
        updatePredictionUI(prediction);
        updateRecentResults();
        updatePatternDetails(prediction);
        
        // Add console log with analysis
        if (prediction.analysis) {
          addConsoleLogFromPrediction(
            getNextPeriod(gameData[0].issueNumber),
            prediction,
            prediction.analysis
          );
        }
      }
    }

    // Auto reload each minute + 8s
    function setupPageReload() {
      const now = new Date();
      const msToNextMinutePlus8 = (60 - now.getSeconds()) * 1000 + 8000;
      setTimeout(() => {
        location.reload();
      }, msToNextMinutePlus8);
    }

    // Init
    window.addEventListener('load', () => {
      renderPredictionHistory();
      renderConsoleLogs();

      newSessionBtn.addEventListener('click', startNewSession);
      

      fetchDataAndPredict();
      setupPageReload();
    });
function sendToTelegram(message) {
  const BOT_TOKEN = "PASTE_YOUR_BOT_TOKEN_HERE";
  const CHAT_ID = "PASTE_YOUR_CHAT_ID_HERE";

  const url =
    `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;

  fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      chat_id: CHAT_ID,
      text: message,
      parse_mode: "HTML"
    })
  }).catch(err => console.error("Telegram Error", err));
}
  </script>
<script>
document.addEventListener("click", enableSound, { once: true });
document.addEventListener("touchstart", enableSound, { once: true });

function enableSound() {
  const audio = new Audio();
  audio.src = "win.mp3"; // or any sound file
  audio.play().then(() => {
    audio.pause();
    audio.currentTime = 0;
    console.log("Sound unlocked");
  }).catch(() => {});
}
</script>
</body>
</html>
